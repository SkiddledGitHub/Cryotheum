/**
 * @license
 * @copyright Copyright 2022 ZenialDev
 *
 * This file is part of Cryotheum.
 * Cryotheum is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * Cryotheum is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with the Cryotheum source code. 
 * If not, see <https://www.gnu.org/licenses/>.
 *
 */

// 3rd party modules
const axios = require('axios');

/**
 * This module's main exception function.
 * @function
 * @constructor
 * @param {Object} options - Options for the exception
 * @param {string} options.message - Message for the exception
 * @param {Object} options.res - Response data if any
 * @example
 * throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
 */
function InvidiousException(options) {
  this.message = options.message;
  this.name = 'InvidiousException';
  if (options.res) {
    this.res = options.res;
  };
}

var self = module.exports = {
    /**
     * Get Invidious HTTPS instances with API endpoints available.
     * @function
     * @async
     * @returns {Array} Returns an array with Invidious HTTPS instances and their URLs
     */
    getHttpsInstances: async function() {
        let instances = [];
        let response;

        await axios
          .get('https://api.invidious.io/instances.json?pretty=1&sort_by=type,users,api')
          .then(res => {
            response = res.data;
          })
          .catch(e => {
            throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
            return undefined;
          })

          response.forEach((item) => {
            if (item[1].type === 'https' && item[1].api) {
                instances.push({ name: item[0], url: item[1].uri });
            }
          })
          return instances;
    },
    /**
     * Sorts Invidious API responses
     * @function
     * @param {Object} data - Data recieved from Invidious API. !!! Use forEach and pass the item value if it's an array !!!
     * @param {string} operation - Sorting type ("search", "video", "playlist", "channel", "channelVideos", "channelLatestVideos", "channelPlaylists")
     * @example
     * invidious.sort(data, 'video');
     * @returns {Object} Sorted data object
     */
    sort: function(data, operation) {
        if (!operation) return data;

        if (operation === 'search') {
            if (data.type === 'video') return {
                type: data.type,
                metadata: { title: data.title, id: data.videoId, viewCount: data.viewCount, length: data.lengthSeconds, thumbnails: data.videoThumbnails, published: { timestamp: data.published, text: data.publishedText } },
                author: { name: data.author, id: data.authorId, url: data.authorUrl }
            }

            if (data.type === 'playlist') { 
                let tempData = {
                    type: data.type,
                    metadata: { title: data.title, id: data.playlistId, thumbnails: data.playlistThumbnail, videoCount: data.videoCount },
                    author: { name: data.author, id: data.authorId, url: data.authorUrl, verified: data.authorVerified },
                    videos: []
                }

                data.videos.forEach((item) => {
                    tempData.videos.push({ title: item.title, id: item.videoId, thumbnails: item.videoThumbnails, length: item.lengthSeconds });
                })

                return tempData;
            }

        if (data.type === 'channel') return {
            type: data.type,
            author: { name: data.author, id: data.authorId, url: data.authorUrl, verified: data.authorVerified, thumbnails: data.authorThumbnails, autoGenerated: data.autoGenerated, subCount: data.subCount, videoCount: data.videoCount, description: data.description }
        }

      } else if (operation === 'video') {
            return {
                type: data.type,
                metadata: {
                    title: data.title, id: data.videoId, thumbnails: data.videoThumbnails, description: data.description,
                    published: { timestamp: data.published, text: data.publishedText },
                    keywords: data.keywords, viewCount: data.viewCount, likeCount: data.likeCount,
                    paid: data.paid ? true : false, premium: data.premium, allowedRegions: data.allowedRegions,
                    genre: data.genre, length: data.lengthSeconds, liveNow: data.liveNow, upcoming: data.isUpcoming
                },
                video: { dash: data.dashUrl, adaptive: data.adaptiveFormats, streams: data.formatStreams, captions: data.captions },
                author: { name: data.author, subCount: data.subCountText, id: data.authorId, url: data.authorUrl, thumbnails: data.authorThumbnails }
            }

        } else if (operation === 'playlist') {
            let tempData = {
                type: data.type,
                metadata: {
                    title: data.title, id: data.playlistId, thumbnail: data.playlistThumbnail, description: data.description,
                    videoCount: data.videoCount, viewCount: data.viewCount, updated: data.updated
                },
                author: { name: data.author, id: data.authorId, url: data.authorUrl, thumbnails: data.authorThumbnails },
                videos: []
            }

            data.videos.forEach((item) => {
                tempData.videos.push({
                    metadata: { title: item.title, id: item.videoId, thumbnails: item.videoThumbnails, length: item.lengthSeconds, index: item.index },
                    author: { name: item.author, id: item.authorId, url: item.authorUrl }
                })
            })

            return tempData;
        
        } else if (operation === 'channel') {
            let tempData = {
                author: {
                    name: data.author, id: data.authorId, url: data.authorUrl, banners: data.authorBanners,
                    thumbnails: data.authorThumbnails, subCount: data.subCount, views: data.totalViews,
                    joined: data.joined, autoGenerated: data.autoGenerated, familyFriendly: data.isFamilyFriendly,
                    description: data.description, allowedRegions: data.allowedRegions
                },
                misc: {
                    latestVideos: [], relatedChannels: []
                }
            };

            data.latestVideos.forEach((item) => {
                tempData.misc.latestVideos.push({
                    metadata: {
                        title: item.title, id: item.videoId, thumbnails: item.videoThumbnails, viewCount: item.viewCount,
                        published: { timestamp: item.published, text: item.publishedText },
                        length: item.lengthSeconds, live: item.liveNow, premium: item.premium, upcoming: item.isUpcoming
                    },
                    author: { name: item.author, id: item.authorId, url: item.authorUrl
                    }
                })
            })

            data.relatedChannels.forEach((item) => {
                tempData.misc.relatedChannels.push({ author: { name: item.author, id: item.authorId, url: item.authorUrl, thumbnails: item.authorThumbnails } })
            })

            return tempData;

        } else if (operation === 'channelVideos') {
            return {
                metadata: {
                    title: data.title, id: data.videoId, thumbnails: data.videoThumbnails, description: data.description,
                    viewCount: data.viewCount, published: { timestamp: data.published, text: data.publishedText },
                    paid: data.paid ? true : false, premium: data.premium
                },
                author: { name: data.author, id: data.authorId, url: data.authorUrl }
            }
        } else if (operation === 'channelLatestVideos') {
            return {
                metadata: {
                    title: data.title, id: data.videoId, thumbnails: data.videoThumbnails, description: data.description,
                    published: { timestamp: data.published, text: data.publishedText },
                    viewCount: data.viewCount, length: data.lengthSeconds, paid: data.paid ? true : false, premium: data.premium
                },
                author: { id: data.authorId, url: data.authorUrl }
            }
        } else if (operation === 'channelPlaylists') {
            return {
                type: data.type,
                metadata: { title: data.title, id: data.playlistId, thumbnail: data.playlistThumbnail, videoCount: data.videoCount },
                author: { name: data.author, id: data.authorId, url: data.authorUrl, verified: data.authorVerified }
            }
        }
    },
    /**
     * Search using the Invidious search endpoint.
     * @function
     * @async
     * @param {string} query - Search query
     * @param {Object} options - Axios parameters
     * @param {Number} [options.page] - Change search page
     * @param {string} [options.sort_by] - Sort search results ("relevance", "rating", "upload_date", "view_count")
     * @param {string} [options.date] - Sort search results by creation date ("hour", "today", "week", "month", "year")
     * @param {string} [options.duration] - Sort search results by duration ("short", "long")
     * @param {string} [options.type] - Sort search results by their type ("video", "playlist", "channel", "all")
     * @param {string} [options.features] - Sort search results by their features ("hd", "subtitles", "creative_commons", "3d", "live", "purchased", "4k", "360", "location", "hdr", comma-seperated: hd,live,360)
     * @param {string} [options.region] - ISO 3166 country code (default: "US")
     * @param {Number} maximum - Maximum amount of search results to keep (default: 5)
     * @example
     * indivious.search('pewdiepie', { date: 'year' }, maximum: 4);
     * @returns {Array} An array with search results.
     */
    search: async function(query, options, maximum) {
        if (!query) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a search query!' });
            return undefined;
        }
        let searchResults = []; 

        let maxQuery;
        if (!maximum) {
            maxQuery = 5;
        } else if (maximum > 30) {
            maxQuery = 30;
        } else {
            maxQuery = maximum;
        }

        let axiosOptions = { params: { pretty: 1, q: query } };
        if (options) {
            Object.keys(options).forEach((item) => {
                axiosOptions.params[item] = `${options[item]}`;
            })
        }

        let instances = await self.getHttpsInstances();

        let response;

        await axios
           .get(`${instances[0].url}/api/v1/search`, axiosOptions)
           .then(res => {
                response = res.data;
           })
           .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
           })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }
        if (response.length === 0) {
            throw new InvidiousException({ message: `Invidious raised an exception: API returned nothing`, res: response });
            return undefined;
        }

        let resultData;
        response.forEach((item, index) => {
            if ((index < (maxQuery)) && !item.isUpcoming && !item.premium) {
                searchResults.push(self.sort(item, 'search'));
            }
        })

        return searchResults;
    },
    /**
     * Get a video's data.
     * @function
     * @async
     * @param {string} videoID - The video's ID.
     * @example
     * invidious.getVideo('eHL0r0r69cE');
     * @returns {Object} Video data
     */
    getVideo: async function(videoID) {
        if (!videoID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a video ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        await axios
            .get(`${instances[0].url}/api/v1/videos/${videoID}`, { params: { pretty: 1 } })
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }

        return self.sort(response, 'video');
    },
    /**
     * Get a playlist's data.
     * @function
     * @async
     * @param {string} playlistID - The playlist's ID
     * @example
     * invidious.getPlaylist('PLYH8WvNV1YEnLCzUDWueIZQXDNhqLKywk');
     * @returns {Object} Playlist data
     */
    getPlaylist: async function(playlistID) {
        if (!playlistID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a playlist ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        await axios
            .get(`${instances[0].url}/api/v1/playlists/${playlistID}`, { params: { pretty: 1 } })
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }

        return self.sort(response, 'playlist');
    },
    /**
     * Get a channel's data
     * @function
     * @async
     * @param {string} channelID - The channel's ID
     * @param {Object} options - Axios parameters
     * @param {string} [options.sort_by] - Sort channel ("newest", "oldest", "popular", default: newest)
     * @example
     * invidious.getChannel('UC-lHJZR3Gqxm24_Vd_AJ5Yw');
     * @returns {Object} Channel's data
     */
    getChannel: async function(channelID, options) {
        if (!channelID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a channel ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        let axiosOptions = { params: { pretty: 1 } };
        if (options) {
            Object.keys(options).forEach((item) => {
                axiosOptions.params[item] = `${options[item]}`;
            })
        }

        await axios
            .get(`${instances[0].url}/api/v1/channels/${channelID}`, axiosOptions)
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response })
            return undefined;
        };

        return self.sort(response, 'channel');
    },
    /**
     * Get channel's videos.
     * @function
     * @async
     * @param {string} channelID - The channel's ID
     * @param {Object} options - Axios parameters
     * @param {Number} [options.page] - Select page
     * @param {string} [options.sort_by] - Sort videos ("newest", "oldest", "popular", default: newest)
     * @example
     * invidious.getChannelVideos('UC-lHJZR3Gqxm24_Vd_AJ5Yw');
     * @return {Array} An array with up to 30 channel videos
     */
    getChannelVideos: async function(channelID, options) {
        if (!channelID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a channel ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        let axiosOptions = { params: { pretty: 1 } };
        if (options) {
            Object.keys(options).forEach((item) => {
                axiosOptions.params[item] = `${options[item]}`;
            })
        }

        await axios
            .get(`${instances[0].url}/api/v1/channels/videos/${channelID}`, axiosOptions)
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }

        let channelVideos = [];
        response.forEach((item) => {
            channelVideos.push(self.sort(item, 'channelVideos'))
        })

        return channelVideos;
    },
    /**
     * Get channel's latest videos.
     * @function
     * @async
     * @param {string} channelID - The channel's ID
     * @example
     * invidious.getChannelLatestVideos('UC-lHJZR3Gqxm24_Vd_AJ5Yw');
     * @return {Array} An array with up to 30 channel latest videos
     */
    getChannelLatestVideos: async function(channelID) {
        if (!channelID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a channel ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        await axios
            .get(`${instances[0].url}/api/v1/channels/latest/${channelID}`, { params: { pretty: 1 } })
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }

        let latestVideos = [];
        response.forEach((item) => {
            latestVideos.push(self.sort(item, 'channelLatestVideos'))
        })

        return latestVideos;
    },
    /**
     * Get channel's playlists.
     * @function
     * @async
     * @param {string} channelID - The channel's ID
     * @param {Object} options - Axios parameters
     * @param {Number} [options.continuation] - Continuation string
     * @param {string} [options.sort_by] - Sort videos ("oldest", "newest", "last")
     * @example
     * invidious.getChannelVideos('UC-lHJZR3Gqxm24_Vd_AJ5Yw');
     * @returns {Array} An array with data with up to 29 channel playlists
     */
    getChannelPlaylists: async function(channelID, options) {
        if (!channelID) {
            throw new InvidiousException({ message: 'Invidious raised an exception: You must provide a channel ID!' });
            return undefined;
        }
        let instances = await self.getHttpsInstances();

        let response;

        let axiosOptions = { params: { pretty: 1 } };
        if (options) {
            Object.keys(options).forEach((item) => {
                axiosOptions.params[item] = `${options[item]}`;
            })
        }

        await axios
            .get(`${instances[0].url}/api/v1/channels/playlists/${channelID}`, axiosOptions)
            .then(res => {
                response = res.data;
            })
            .catch(e => {
                throw new InvidiousException({ message: `Axios raised an exception: ${e.message}`, res: e.res });
                return undefined;
            })
        if (response.error) {
            throw new InvidiousException({ message: `Invidious raised an exception: ${response.error}`, res: response });
            return undefined;
        }

        let channelPlaylists = [];
        let continuation = undefined;
        if (response.continuation) {
            continuation = response.continuation;
        }

        response.playlists.forEach((item) => {
            channelPlaylists.push(self.sort(item, 'channelPlaylists'))
        })

        return { playlists: channelPlaylists, continuation: continuation };
    }
}